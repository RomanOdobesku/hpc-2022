## Описание работы
Было взято исходное изображение девушки Лены, которое имеет размер 1024х1024. 
Далее на сервере преподавателя проводились эксперименты (вход выполнялся через Андреева Александра).
Входное и полученные изображения приложены в репозиторий. Качество работы на CPU и GPU одинаковое и адекватно для всех размеров изображений.
Стоит отметить, что в работе измерение времени производилось с учетом копирования в GPU массивы (как рекомендовалось на паре).
## Что распараллеливалось
Распараллеливалась операция вычисления каждого пиксела. Каждая нить занималась вычислением своего пикселя. Вся остальная логика остается прежней и ничем не отличается от последовательной программы.
## Краткое описание Main
1. Обработка входного изображения
2. Выделение памяти
3. Выделение текстурной памяти
4. Начало замера времени распараллеленного алгоритма
5. Копирование на GPU
6. Запуск ядра -> Вычисление на GPU
7. Копирования обратно на CPU
8. Окончание замера времени распараллеленного алгоритма
9. Запуск последовательного алгоритма
10. Замер времени
11. Вычисление ускорения
12. Очищение памяти
## Исходные данные для эксперимента
### Цветное изображение
![Lena1024](https://user-images.githubusercontent.com/60855603/202436462-3a5de29a-b4b9-4263-b047-f7bf7ce6bdf5.jpg) </br>
## Удобная фишка
Добавил отрисовку процентов в ходе работы и примерное время окончания. Отрисовка производится на каждой итерации. За идею спасибо Андрееву Александру.
### Время
Считается время выполнения за 1 внешний цикл, а потом происходит вычисление с использованием номера итерации.
![image](https://user-images.githubusercontent.com/60855603/202438578-15aab62c-95c5-4395-950a-947c42b771fd.png) </br>
![image](https://user-images.githubusercontent.com/60855603/202438645-076b4814-d201-4cc8-bcec-e369860f393f.png) </br>
![image](https://user-images.githubusercontent.com/60855603/202438912-5c3528c6-6679-4ffa-b3cb-4badbc6844da.png) </br>
## Результаты
### Результат работы ядра с sigmaD = 0.7, sigmaR = 20 (outputGPU1024_(0.7,20))
![outputGPU1024_(0.7,20)](outputGPU1024_(0.7,20).bmp)
### Результат работы ядра с sigmaD = 1.5, sigmaR = 10 (outputGPU1024_(1.5,10))
![outputGPU1024_(1.5,10)](outputGPU1024_(1.5,10).bmp)
### Результат работы ядра с sigmaD = 1.5, sigmaR = 20 (outputGPU1024_(1.5,20))
![outputGPU1024_(1.5,20)](outputGPU1024_(1.5,20).bmp)
### Результат работы ядра с sigmaD = 1.5, sigmaR = 100 (outputGPU1024_(1.5,100))
![outputGPU1024_(0.7,20)](outputGPU1024_(0.7,20).bmp)
### Результат работы ядра с sigmaD = 3, sigmaR = 20 (outputGPU1024_(3,20))
![outputGPU1024_(3,20)](outputGPU1024_(3,20).bmp)
### Численные значения
Значения полученные при проведении эксперимента: </br> 
![image](https://user-images.githubusercontent.com/60855603/203954608-92474a46-d54e-4354-a702-bf250e2dda39.png) </br>
### Графики
График ускорения:</br>
![image](https://user-images.githubusercontent.com/60855603/203954453-38fc606a-247a-4aa6-9950-ad55a0f472d7.png)
</br>
Графики времени выполнения: </br>
![image](https://user-images.githubusercontent.com/60855603/203954488-9a008297-6db7-4ecf-a06a-6a8eddb12d7a.png)
![image](https://user-images.githubusercontent.com/60855603/203954526-4b4e6cc0-ce26-4214-94d9-0c78cc072def.png)
</br>
## Вывод
Для этой задачи необходимо использовать CUDA, т.к. она дает огромное ускорение. Количество нитей в видеокарте достаочно велико, чтобы каждая нить занималась только своим пикселем при размере 1024 на 1024, при желании можно обрабатывать даже большие размеры изображения.
